# 锁

## 锁优化
> 目的：减少锁操作的开销、

### 1. 自旋锁
线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。

#### 何谓自旋锁？
所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。

### 2. 适应性自旋锁
自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定

### 3. 锁消除
不必要用锁的地方，不再加锁，主要是内置api，如hashTable\Venctor

### 4. 锁粗化
减少连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，例如：加锁解锁操作会移到for循环之外
### 5. 偏向锁
### 6. 轻量级锁


## 参考
[【死磕Java并发】-----深入分析synchronized的实现原理](http://cmsblogs.com/?p=2071)
